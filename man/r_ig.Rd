% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simul.R
\name{r_ig}
\alias{r_ig}
\title{Simulate Independent Group Framework}
\usage{
r_ig(n_1, n_2, p_1 = F, p_2 = F, dir_1 = F, dir_2 = F)
}
\arguments{
\item{n_1}{\code{numeric} representing the number of individuals from group 1.}

\item{n_2}{\code{numeric} representing the number of individuals from group 2.}

\item{p_1}{\code{vector} of probability for group 1.}

\item{p_2}{\code{vector} of probability for group 2.}

\item{dir_1}{\code{vector} the shape parameter of the Dirichlet-multinomial
for group 1.}

\item{dir_2}{\code{vector} the shape parameter of the Dirichlet-multinomial
for group 2.}
}
\value{
\code{matrix} containing the generated sample
}
\description{
\code{r_independent_group} samples from two independent multinomial
distribution or, following a simple conjugate model, two Dirichlet-
multinomial. Returns the sample in the form of a matrix. At least, one
among p_1 and dir_1 and one among p_2 and dir_2 must be specified.
The length of p_1 (dir_1) and p_2 (dir_2) must be identical.
}
\details{
Simulate one sample from two independent distributions, one per group. The
user can sample from two independent multinomial, two independent
Dirichlet-multinomial, a multinomial for group 1 and Dirichlet-multinomial
for group 2, or vice-versa. The multinomial distributions will take as
probability vectors p_1 and p_2. The Dirichlet-multinomial distributions will
take as alpha vectors dir_1 and dir_2. In case p_1 (p_2) is specified,
dir_1 (dir_2) will be ignored and group 1 (2) will be sampled from a multinomial
distribution. p_1 and p_2 do not have to be normalized.

At least, one among p_1 and dir_1 and one among p_2 and dir_2 must be
specified. The length of p_1 (dir_1) and p_2 (dir_2) must be identical.
}
\examples{
env <- matrix(c(1,2,3,4,5,6,7,8), nrow = 2, byrow = TRUE)
n_1 <- sum(env[1,])
n_2 <- sum(env[2,])
p_1 <- env[1,]
p_2 <- env[2,]
samp <- r_independent_group(n_1 = n_1, n_2 = n_2, p_1 = p_1, p_2 = p_2)
samp2 <- r_independent_group(n_1 = n_1, n_2 = n_2, dir_1 = p_1, dir_2 = p_2)
all.equal(rowSums(env), rowSums(samp), rowSums(samp2))
}
\seealso{
Other frameworks: 
\code{\link{r_fm}()},
\code{\link{r_iu}()}
}
\concept{frameworks}
